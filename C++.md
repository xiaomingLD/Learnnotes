# C++

*静态类型的，编译式的，通用的，大小写敏感的，不规则的编程语言，支持过程化编程，面向对象编程和泛型编程。*

使用静态类型的编程语言是在编译时执行类型检查，而不是在运行时执行类型检查。

> 面向对象的四大特性: 封装，抽象，继承，多态



## 注释：

C++ 注释以 `/*` 开始，以 `*/` 终止，多行注释

注释也能以 // 开始，单行注释


typedef 声明
可以使用 typedef 为一个已有的类型取一个新的名字。 typedef type newname;

枚举类型，如果一个变量只有几种可能的值，可以定义为（enumeration）类型。枚举类型的一般形式为：

enum 枚举名{
     标识符[=整型常数],
     标识符[=整型常数],
...
    标识符[=整型常数]
} 枚举变量;


变量声明：
int    i, j, k;
char   c, ch;
float  f, salary;
double d;

变量声明向编译器保证变量以给定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。

可以在 C++ 程序中多次声明一个变量，但变量只能在某个文件、函数或代码块中被定义一次。
```c++
#include <iostream>
using namespace std;

// 变量声明
extern int a, b;
extern int c;
extern float f;

int main ()
{
  // 变量定义
  int a, b;
  int c;
  float f;

  // 实际初始化
  a = 10;
  b = 20;
  c = a + b;

  cout << c << endl ;

  f = 70.0/3.0;
  cout << f << endl ;

  return 0;
}
```

## 变量的声明有两种情况：

1、一种是需要建立存储空间的。例如：int a 在声明的时候就已经建立了存储空间。

2、另一种是不需要建立存储空间的。 例如：extern int a 其中变量a是在别的文件中定义的。

前者是“定义性声明（defining declaration）”或者称为“定义（definition）”，而后者是“引用性声明（referncing declaration）”，从广义的角度来讲声明中包含着定义，即定义是声明的一个特例，所以并非所有的声明都是定义，例如：int a 它既是声明，同时又是定义。然而对于 extern a 来讲它只是声明不是定义。一般的情况下我们常常这样叙述，把建立空间的声明称之为“定义”，而把不需要建立存储空间的声明称之为“声明”

函数和变量一样，使用前一定要先声明或者定义，定义本身也是一次声明。


C++ 中的左值（Lvalues）和右值（Rvalues）
C++ 中有两种类型的表达式：

左值（lvalue）：指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。
右值（rvalue）：术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。
变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值

# define 预处理器

#define identifier value

可以使用const前缀声明制定类型的常量

const type variable = value;

C++ 修饰符类型

C++ 中的类型限定符

_const_     
const 类型的对象在程序执行期间不能被修改改变
_volatile_
volatile告诉编译器不要优化volatile声明的变量

## C++ 存储类

C++ 程序中可用的存储类：

* auto
* register
* static
* extern
* mutable
* thread_local

存储类定义程序中变量/函数的范围和生命周期

### auto
auto关键字用于两种情况：

* 声明变量时根据初始化表达式自动推断该变量的类型
* 声明函数时函数返回值得占位符

### static

编译器在程序的声明周期内保持局部变量的存在，不需要每次它进入和离开作用域时进行创建和销毁。使用static修饰局部变量可以在函数调用期间保持局部变量的值。

static修饰全局变量时，会使变量的作用域限制在声明它的文件内。

### extern
extern存储类提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。

### mutable

仅适用于类的对象


## C++运算符

* 算术运算符
* 关系运算符
* 逻辑运算符
* 位运算符
* 赋值运算符
* 杂项运算符

### 杂项运算符

> sizeof

sizeof 运算符返回变量的大小

> Condition ? X : Y

条件运算符，如果Condition为真？则值为X：否则值为Y

>，

逗号运算符会执行一系列运算

>. 和 ->

成员运算符用于引用类、结构和共用体的成员

> Cast

> &

指针运算符&返回变量的地址。例如 &a ; 将给出变量的实际地址

> *

指针运算符，指向一个变量

## C++ 中的运算符优先级

 ## C++ 函数

 ### 定义函数

return_type function_name( parameter list )
{
   body of the function
}

### 函数声明

### 函数参数

* 传值调用，形式参数，修改形参对实际参数没有影响
* 指针调用， 把参数的地址复制给形参，修改形式参数会影响实际参数
* 引用调用， 把参数的引用复制给形式参数，修改形式参数会影响实际参数

## Lambda 函数与表达式

匿名函数，称谓Lambda 函数

```
[capture](parameters)->return-type{body}

[capture](parameters){body}

```


## C++ 数字

## C++ 随机数

# C++ 数组

> 在 C++ 中声明一个数组，要指定元素的类型和元素的数量

```

type arrayName [ arraySize ];

```

### C++ 多维数组

```

type name[size1][size2]...[sizeN];

```

### 指向数组的指针

数组名是一个指向数组中第一个元素的常量指针。

## C++ 字符串

C++ 提供了两种字符串的表示形式：
* C风格字符串
* C++ String类型

### C风格字符串

字符串实际上是使用null字符'\0'终止的一维字符数组

```
char greeting[6] = {'H', 'e', 'l', 'l', 'o', '\0'};

```



## C++ 指针

* 动态内存分配

> 每一个变量都有一个内存位置，每一个内存位置都定义了可用连字符 & 运算符访问的地址，它表示了内存中的一个地址

> 指针是一个变量，其值为另一个变量的地址，即，内存位置的直接地址

` type *var-name; `

使用指针会频繁的进行以下几个操作：

1. 定义一个指针变量
2. 把变量地址赋值给指针
3. 访问指针变量中可用地址的值

## C++ Null 指针

## C++ 指针和数组

一个数组名对应一个指针常量

## C++ 指向指针的指针

> C++ 不支持在函数外返回局部变量的地址，除非定义局部变量为static

## C++ 引用

引用和指针的区别：

* 不存在空引用，引用必须连接到一块合法的内存
* 一旦引用被初始化为一个对象，就不能被指向到另一个对象
* 引用必须在创建时被初始化，指针可以在任何时候被初始化

## C++ 把引用作为参数

## C++ 把引用作为返回值

> 再返回一个引用时，被引用的对象不能超出作用域，所以返回一个对局部变量的引用时不合法的。但是，可以返回一个对静态变量的引用

C++ 基本的输入输出

## C++ 数据结构

> C++ 中的结构是一种用户自定义的可用的数据类型，它允许存储不同类型的数据项

```
struct type_name {
member_type1 member_name1;
member_type2 member_name2;
member_type3 member_name3;
.
.
} object_names;

```

结构可以作为函数参数

可以定义指向结构的指针

`struct Books *struct.pointer`

`.` 成员访问运算符

`->` 指向结构的指针访问结构的成员

##typedef 关键字


## C++ 类和对象

`public` 确定了类成员的访问属性，在类对象作用域内，公共成员在类的外部是可访问的。公有成员可以使用成员访问符`.`来直接访问

## 类访问修饰符

`public, private, protected` 访问修饰符， 成员和类的默认访问修饰符是private

> 公有成员 `public`

公有成员在程序类的外部是可访问的，可以不适用任何成员函数来设置和获取公有变量的值

> 私有成员 `private`

私有成员变量或者函数在类的外部是不可访问的，甚至是不可查的，只有类和友元函数可以访问私有成员。

> 保护成员 protected

保护成员变量或函数与私有成员十分相似，但是，保护成员在子类中可以访问

## C++ 继承

继承允许我们依据一个类来定义一个类，这使得创建和维护一个应用程序变得容易，达到了重用代码功能和提高执行时间的效果

继承代表了 is a 的关系

一个类可以派生自多个类，这意味着，他可以从多个基类继承数据和函数


## 继承的特点

有public，protected，private三种继承，他们相应的改变了基类成员的访问属性

* public 继承，基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：public, protected, private

* protectd 继承： 基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：protected, protected, private

* private 继承，基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：private, private, private

一个派生类继承了所有的基类方法，下列情况除外：

* 基类的构造函数、析构函数和拷贝构造函数
* 基类的重载运算符
* 基类的友元函数

## C++ 重载运算符和重载函数

重载声明是指一个与之前已经在该作用域内声明过得函数或者方法具有相同名称的声明，但是他们的参数列表和定义不相同


## C++多态

## C++ 数据抽象

## C++ 接口（抽象类）

接口描述了类的行为和功能，而不需要完成类的特定实现。

C++ 接口是使用抽象类来实现的，抽象类与数据抽象互不混淆，数据抽象是一个把实现细节与相关的数据分离开的概念。

如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 "= 0" 来指定的


抽象类不能被用于实例化对象，它只能作为接口使用。如果试图实例化一个抽象类的对象，会导致编译错误

## C++ 异常处理

C++ 异常处理涉及到三个关键字：try、catch、throw

* throw 当问题出现时，程序会抛出一个异常
* catch 用于捕获异常
* try   try块中的代码表示将被激活的特定异常

捕获异常的方法会使用 try 和 catch 关键字。try 块中放置可能抛出异常的代码，try 块中的代码被称为保护代码。

```
try
{
   // 保护代码
}catch( ExceptionName e1 )
{
   // catch 块
}catch( ExceptionName e2 )
{
   // catch 块
}catch( ExceptionName eN )
{
   // catch 块
}

```


## C++ 动态内存

C++ 程序中的内存分为两个部分：

* 栈：在函数内部声明的所有变量占用栈内存
* 堆：程序中未使用的内存，在程序运行时可用于动态分配内存

为给定类型的变量在运行时分配堆内的内存，这会返回所分配的空间地址，即new运算符

## C++ 命名空间

命名空间可以作为附加信息来区分不同库中相同名称的函数、类、变量等。

命名空间的定义使用关键字 namespace

```
namespace namespace_name {
   // 代码声明
}

```

调用带有命名空间的函数或者变量，需要在前面加上命名空间的名称

`name::code`

## C++ 模板

模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。


* 函数模板
* 类模板

函数模板仅针对参数类型不同的函数

类模板针对仅数据成员和成员函数类型不同的类。

_模板的声明或定义只能在全局，命名空间或类范围内进行。即不能在局部范围，函数内进行，比如不能在main函数中声明或定义一个模板。_

> 函数模板的格式：

```

template <class type> ret-type func-name(parameter list)
{
   // 函数的主体
}

template <class 形参名，class 形参名，......> 返回类型 函数名(参数列表)

　　　{

　　　　　　函数体

　　　}

```

> 类模板通式

```

template<class  形参名，class 形参名，…>   class 类名

　　　　{ ... };

```


## C++ 预处理

> 预处理器是一些指令，指示编译器在实际编译之前所需完成的预处理。

C++ 的预处理指令

* #include
* #define 参数宏
* #if
* #else
* #line

条件编译


## C++ 信号处理

两种类型的多任务处理：基于进程和基于线程

* 基于进程的多任务处理是程序的并发执行
* 基于线程的多任务处理是同一程序的片段的并发执行


## C++ STL教程

C++ 标准模板库的核心包括以下三个组件：

1. 容器 Containers
2. 算法 Algorithms
3. 迭代器 iterators
