# C++ 模板

---
## C++ 模板类的声明和实现为什么要在一个头文件中

[相关文章](https://blog.csdn.net/u010273652/article/details/21568131)

> 原因：

在分离式编译的环境下，编译器编译某一个.cpp文件时并不知道另一个.cpp文件的存在，也不会去查找（当遇到未决符号时它会寄希望于连接器）。这种模式在没有模板的情况下运行良好，但遇到模板时就傻眼了，因为模板仅在需要的时候才会实例化出来，所以，当编译器只看到模板的声明时，它不能实例化该模板，只能创建一个具有外部连接的符号并期待连接器能够将符号的地址决议出来。然而当实现该模板的.cpp文件中没有用到模板的实例时，编译器懒得去实例化，所以，整个工程的.obj中就找不到一行模板实例的二进制代码，于是连接器也黔驴技穷了。

> 编译单元 translation unit

一个编译单元是指一个 `.cpp` 文件以及它所 `#include` 的所有 `.h` 文件

1. 在编译过程中，`.h` 文件里的代码将会被扩展到包含他的 `.cpp` 文件里，然后编译器编译该 `.cpp` 文件为一个 `.obj` 文件。

2. 当编译器将一个工程里的所有 `.cpp` 文件以分离的方式编译完毕后，再由连接器 (linekr) 进行连接成为一个 `.exe` 文件。


```
//---------------test.h-------------------//

void f();//这里声明一个函数f

//---------------test.cpp--------------//

#include ”test.h”

void f()

{

…//do something

} //这里实现出test.h中声明的f函数

//---------------main.cpp--------------//

#include ”test.h”

int main()

{

f(); //调用f，f具有外部连接类型

}


```
<table><tr><td bgcolor=orange>* 编译main.cpp时，编译器不知道f的实现，所以当碰到对它的调用时只是给出一个指示，指示连接器应该为它寻找f的实现体。这也就是说main.obj中没有关于f的任何一行二进制代码。</td></tr></table>

<table><tr><td bgcolor=orange>* 编译test.cpp时，编译器找到了f的实现。于是乎f的实现（二进制代码）出现在test.obj里。</td></tr></table>

<table><tr><td bgcolor=orange>* 连接时，连接器在test.obj中找到f的实现代码（二进制）的地址（通过符号导出表）。然后将main.obj中悬而未决的call  XXX地址改成f实际的地址。</td></tr></table>
